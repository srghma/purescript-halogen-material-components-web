module HalogenMWC.Array where

import Protolude
import DOM.HTML.Indexed as I
import MaterialIconsFont.Classes
import Web.Event.Event

import Data.Array as Array
import Data.Maybe as Maybe
import Halogen
import Halogen.HTML (IProp)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.HTML.Properties.ARIA as Halogen.HTML.Properties.ARIA
import HalogenMWC.Array.Item (Config, ArrayItem)
import HalogenMWC.Array.Item as ArrayItem
import Material.Classes.List

type Config i =
  { nonInteractive :: Boolean
    , dense :: Boolean
    , avatarArray :: Boolean
    , twoLine :: Boolean
    , vertical :: Boolean
    , wrapFocus :: Boolean
    , additionalAttributes :: Array (IProp I.HTMLdiv i)
    }

defaultConfig :: forall i . Config i
defaultConfig =
  { nonInteractive: false
  , dense: false
  , avatarArray: false
  , twoLine: false
  , vertical: false
  , wrapFocus: false
  , additionalAttributes: []
  }

{-| Specify whether a list should be non-interactive

Non-interactive lists do not feature keyboard interaction and list items have
no visual interaction effect.

-}
{-| Array view function

The list view function takes its list items as two arguments. The first
argument represents the first list item, and the second argument reresents the
remaining list items. This way we guarantee lists to be non-empty.

-}
list :: Config i -> ArrayItem r i -> Array (ArrayItem r i) -> HH.HTML w i
list config firstArrayItem remainingArrayItems =
  let
    listItems = [ firstArrayItem ] <> remainingArrayItems
  in
    HH.element (ElemName "mdc-list")
      ( Array.catMaybes
          [ rootCs
          , nonInteractiveCs config
          , denseCs config
          , avatarArrayCs config
          , twoLineCs config
          , wrapFocusProp config
          , clickHandler listItems
          , selectedIndexProp listItems
          ]
          <> config.additionalAttributes
      )
      ( map
          ( \listItem_ -> case listItem_ of
              ArrayItem.ArrayItem { node } -> node
              ArrayItem.ArrayItemDivider node -> node
              ArrayItem.ArrayGroupSubheader node -> node
          )
          listItems
      )

rootCs :: Maybe (IProp r i)
rootCs = Just (HP.class_ mdc_list)

nonInteractiveCs :: Config i -> Maybe (IProp r i)
nonInteractiveCs { nonInteractive } =
  if nonInteractive then
    Just (HP.class_ mdc_list____non_interactive)
  else
    Nothing

denseCs :: Config i -> Maybe (IProp r i)
denseCs { dense } =
  if dense then
    Just (HP.class_ mdc_list____dense)
  else
    Nothing

avatarArrayCs :: Config i -> Maybe (IProp r i)
avatarArrayCs { avatarArray } =
  if avatarArray then
    Just (HP.class_ mdc_list____avatar_list)
  else
    Nothing

twoLineCs :: Config i -> Maybe (IProp r i)
twoLineCs { twoLine } =
  if twoLine then
    Just (HP.class_ mdc_list____two_line)
  else
    Nothing

clickHandler :: Array (ArrayItem r i) -> Maybe (IProp r i)
clickHandler listItems =
  let
    getOnClick listItem_ = case listItem_ of
      ArrayItem.ArrayItem { onClick } -> Just onClick
      ArrayItem.ArrayItemDivider _ -> Nothing
      ArrayItem.ArrayGroupSubheader _ -> Nothing

    nthOnClick index =
      listItems
        # map getOnClick
        # Array.catMaybes
        # Array.drop index
        # Array.head
        # bindFlipped identity

    mergedClickHandler =
      Decode.at [ "detail", "index" ] Decode.int
        # Decode.andThen
            ( \index -> case nthOnClick index of
                Just msg_ -> Decode.succeed msg_
                Nothing -> Decode.fail ""
            )
  in
    Just (HE.handler (EventType "MDCArray:action") mergedClickHandler)

selectedIndexProp :: Array (ArrayItem r i) -> Maybe (IProp r i)
selectedIndexProp listItems =
  let
    selectedIndex :: Array Int
    selectedIndex =
      listItems
        # Array.filter
            ( \listItem_ -> case listItem_ of
                ArrayItem.ArrayItem _ -> true
                ArrayItem.ArrayItemDivider _ -> false
                ArrayItem.ArrayGroupSubheader _ -> false
            )
        # Array.indexedMap
            ( \index listItem_ -> case listItem_ of
                ArrayItem.ArrayItem { selection } ->
                  if selection /= Nothing then
                    Just index
                  else
                    Nothing
                ArrayItem.ArrayItemDivider _ -> Nothing
                ArrayItem.ArrayGroupSubheader _ -> Nothing
            )
        # Array.catMaybes
  in
    Just (HP.prop (PropName "selectedIndex") (Encode.list selectedIndex))

group :: Array (IProp r i) -> Array (HH.HTML w i) -> HH.HTML w i
group additionalAttributes nodes = HH.div ([ listGroupCs ] <> config.additionalAttributes) nodes

listGroupCs :: IProp r i
listGroupCs = HP.class_ mdc_list_group

subheader :: Array (IProp r i) -> Array (HH.HTML w i) -> HH.HTML w i
subheader additionalAttributes nodes = HH.span ([ listGroupSubheaderCs ] <> config.additionalAttributes) nodes

listGroupSubheaderCs :: IProp r i
listGroupSubheaderCs = HP.class_ mdc_list_group__subheader

wrapFocusProp :: Config i -> Maybe (IProp r i)
wrapFocusProp { wrapFocus } = Just (HP.prop (PropName "wrapFocus") wrapFocus)
