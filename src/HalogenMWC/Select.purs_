module HalogenMWC.Select where

import Protolude
import DOM.HTML.Indexed as I
import MaterialIconsFont.Classes
import Web.Event.Event

import Data.Array as Array
import Data.Maybe as Maybe
import Halogen
import Halogen.HTML (IProp)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.HTML.Properties.ARIA as Halogen.HTML.Properties.ARIA
import HalogenMWC.Array as Array
import HalogenMWC.Array.Item as ArrayItem
import HalogenMWC.Icon as Icon
import HalogenMWC.Menu as Menu
import HalogenMWC.Select.Item (SelectItem)
import HalogenMWC.Select.Item as SelectItem
import Material.Classes.Select

type Config a r i
  = { label :: Maybe String
    , disabled :: Boolean
    , required :: Boolean
    , valid :: Boolean
    , selected :: Maybe a
    , leadingIcon :: Maybe (Icon r i)
    , additionalAttributes :: Array (IProp I.HTMLdiv i)
    , onChange :: Maybe (a -> r i)
    }

config :: Config a r i
defaultConfig =
  { label: Nothing
  , disabled: false
  , required: false
  , valid: true
  , selected: Nothing
  , leadingIcon: Nothing
  , additionalAttributes: []
  , onChange: Nothing
  }

data Variant
  = Filled
  | Outlined

select :: Variant -> Config a r i -> SelectItem a r i -> Array (SelectItem a r i) -> HH.HTML w i
select variant (config@{ leadingIcon, selected, additionalAttributes, onChange }) firstSelectItem remainingSelectItems =
  let
    selectedIndex =
      Array.indexedMap
        ( \index (SelectItem.SelectItem { value } _) ->
            if Just value == selected then
              Just index
            else
              Nothing
        )
        [ firstSelectItem, remainingSelectItems ]
        # Array.catMaybes
        # Array.head
  in
    HH.element (ElemName "mdc-select")
      ( Array.catMaybes
          [ rootCs
          , outlinedCs variant
          , leadingIconCs config
          , disabledProp config
          , selectedIndexProp selectedIndex
          , validProp config
          , requiredProp config
          ]
          <> config.additionalAttributes
      )
      [ anchorElt []
          ( Array.concat
              [ [ leadingIconElt config
                , dropdownIconElt
                , selectedTextElt
                ]
              , if variant == Outlined then
                  [ notchedOutlineElt config ]
                else
                  [ floatingLabelElt config
                  , lineRippleElt
                  ]
              ]
          )
      , menuElt leadingIcon selected onChange firstSelectItem remainingSelectItems
      ]

filled :: Config a r i -> SelectItem a r i -> Array (SelectItem a r i) -> HH.HTML w i
filled config firstSelectItem remainingSelectItems = select Filled config firstSelectItem remainingSelectItems

outlined :: Config a r i -> SelectItem a r i -> Array (SelectItem a r i) -> HH.HTML w i
outlined config firstSelectItem remainingSelectItems = select Outlined config firstSelectItem remainingSelectItems

data Icon r i
  = Icon (HH.HTML w i)

icon :: Array (IProp r i) -> String -> Icon r i
icon additionalAttributes iconName = Icon (Icon.icon ([ HP.class_ mdc_select__icon ] <> config.additionalAttributes) iconName)

rootCs :: Maybe (IProp r i)
rootCs = Just (HP.class_ mdc_select)

outlinedCs :: Variant -> Maybe (IProp r i)
outlinedCs variant =
  if variant == Outlined then
    Just (HP.class_ mdc_select____outlined)
  else
    Nothing

leadingIconCs :: Config a r i -> Maybe (IProp r i)
leadingIconCs { leadingIcon } = map (\_ -> HP.class_ mdc_select____with_leading_icon) leadingIcon

disabledProp :: Config a r i -> Maybe (IProp r i)
disabledProp { disabled } = Just (HP.prop (PropName "disabled") disabled)

validProp :: Config a r i -> Maybe (IProp r i)
validProp { valid } = Just (HP.prop (PropName "valid") valid)

selectedIndexProp :: Maybe Int -> Maybe (IProp r i)
selectedIndexProp selectedIndex =
  Just
    ( HP.prop (PropName "selectedIndex")
        (Encode.int (Maybe.fromMaybe - 1 selectedIndex))
    )

requiredProp :: Config a r i -> Maybe (IProp r i)
requiredProp { required } = Just (HP.prop (PropName "required") required)

anchorElt :: Array (IProp r i) -> Array (HH.HTML w i) -> HH.HTML w i
anchorElt additionalAttributes nodes = HH.div ([ HP.class_ mdc_select__anchor ] <> config.additionalAttributes) nodes

leadingIconElt :: Config a r i -> HH.HTML w i
leadingIconElt { leadingIcon } = case leadingIcon of
  Just (Icon icon_) -> icon_
  Nothing -> HH.text ""

dropdownIconElt :: forall w i . HH.HTML w i
dropdownIconElt = HH.i [ HP.class_ mdc_select__dropdown_icon ] []

floatingLabelElt :: Config a r i -> HH.HTML w i
floatingLabelElt { label } = HH.div [ HP.class_ mdc_floating_label ] [ HH.text (Maybe.fromMaybe "" label) ]

lineRippleElt :: forall w i . HH.HTML w i
lineRippleElt = HH.label [ HP.class_ mdc_line_ripple ] []

notchedOutlineElt :: Config a r i -> HH.HTML w i
notchedOutlineElt { label } =
  HH.div [ HP.class_ mdc_notched_outline ]
    [ HH.div [ HP.class_ mdc_notched_outline__leading ] []
    , HH.div [ HP.class_ mdc_notched_outline__notch ]
        [ HH.label [ HP.class_ mdc_floating_label ]
            [ HH.text (Maybe.fromMaybe "" label) ]
        ]
    , HH.div [ HP.class_ mdc_notched_outline__trailing ] []
    ]

menuElt :: Maybe (Icon r i) -> Maybe a -> Maybe (a -> r i) -> SelectItem a r i -> Array (SelectItem a r i) -> HH.HTML w i
menuElt leadingIcon selected onChange firstSelectItem remainingSelectItems =
  Menu.menu
    ( Menu.config
        # Menu.setAttributes
            [ HP.class_ mdc_select__menu
            , style "width" "100%"
            ]
    )
    [ Array.list (Array.config # Array.setWrapFocus true)
        (listItem leadingIcon selected onChange firstSelectItem)
        (map (listItem leadingIcon selected onChange) remainingSelectItems)
    ]

listItem :: Maybe (Icon r i) -> Maybe a -> Maybe (a -> r i) -> SelectItem a r i -> ArrayItem r i
listItem leadingIcon selected onChange (SelectItem.SelectItem config nodes) =
  ArrayItem.listItem (listItemConfig selected onChange config)
    ( if leadingIcon /= Nothing then
        ArrayItem.graphic [] [] :: nodes
      else
        nodes
    )

listItemConfig :: Maybe a -> Maybe (a -> r i) -> SelectItem.Config a r i -> ArrayItem.Config i
listItemConfig selectedValue onChange { value, disabled, additionalAttributes } =
  ArrayItem.config
    # ArrayItem.setDisabled disabled
    # ArrayItem.setAttributes additionalAttributes
    # ( case onChange of
          Just onChange_ -> ArrayItem.setOnClick (onChange_ value)
          Nothing -> identity
      )

selectedTextElt :: forall w i . HH.HTML w i
selectedTextElt = HH.div [ HP.class_ mdc_select__selected_text ] []
