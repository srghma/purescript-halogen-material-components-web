module HalogenMWC.Checkbox where

import Protolude
import DOM.HTML.Indexed as I
import MaterialIconsFont.Classes
import Web.Event.Event

import Data.Array as Array
import Data.Maybe as Maybe
import Halogen
import Halogen.HTML (IProp)
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.HTML.Properties.ARIA as Halogen.HTML.Properties.ARIA
import Halogen.SVG.Attributes as Halogen.SVG.Attributes
import Halogen.SVG.Elements as Halogen.SVG.Elements
import Material.Classes.Checkbox

type Config i =
  { state :: Maybe State
    , disabled :: Boolean
    , additionalAttributes :: Array (IProp I.HTMLdiv i)
    , onChange :: Maybe (Event -> i)
    , touch :: Boolean
    }

data State
  = Unchecked
  | Checked
  | Indeterminate

defaultConfig :: forall i . Config i
defaultConfig =
  { state: Nothing
  , disabled: false
  , additionalAttributes: []
  , onChange: Nothing
  , touch: true
  }

checkbox :: forall w i . Config i -> HH.HTML w i
checkbox (config@{ touch, additionalAttributes }) =
  let
    wrapTouch node =
      if touch then
        HH.div [ HP.class_ mdc_touch_target_wrapper ] [ node ]
      else
        node
  in
    wrapTouch
      $ HH.element (ElemName "mdc-checkbox")
          ( Array.catMaybes
              [ rootCs
              , touchCs config
              , checkedProp config
              , indeterminateProp config
              , disabledProp config
              ]
              <> config.additionalAttributes
          )
          [ nativeControlElt config
          , backgroundElt
          ]

rootCs :: Maybe (IProp r i)
rootCs = Just mdc_checkbox

touchCs :: Config i -> Maybe (IProp r i)
touchCs { touch } =
  if touch then
    Just mdc_checkbox____touch
  else
    Nothing

checkedProp :: Config i -> Maybe (IProp r i)
checkedProp { state } = Just (HP.prop (PropName "checked") (Encode.bool (state == Just Checked)))

indeterminateProp :: Config i -> Maybe (IProp r i)
indeterminateProp { state } = Just (HP.prop (PropName "indeterminate") (Encode.bool (state == Just Indeterminate)))

disabledProp :: Config i -> Maybe (IProp r i)
disabledProp { disabled } = Just (HP.disabled disabled)

changeHandler :: Config i -> Maybe (IProp r i)
changeHandler { state, onChange } =
  -- Note: MDCArray choses to send a change event to all checkboxes, thus we
  -- have to check here if the state actually changed.
  map
    ( \r i ->
        HE.onValueChange
          ( Decode.at [ "target", "checked" ] Decode.bool
              # Decode.andThen
                  ( \isChecked ->
                      if (isChecked && state /= Just Checked)
                        || (not isChecked && state /= Just Unchecked) then
                        Decode.succeed r i
                      else
                        Decode.fail ""
                  )
          )
    )
    onChange

nativeControlElt :: forall w i . Config i -> HH.HTML w i
nativeControlElt config =
  HH.input
    ( Array.catMaybes
        [ Just (HP.type_ "checkbox")
        , Just mdc_checkbox__native_control
        , checkedProp config
        , indeterminateProp config
        , changeHandler config
        ]
    )
    []

backgroundElt :: forall w i . HH.HTML w i
backgroundElt =
  HH.div
    [ HP.class_ mdc_checkbox__background ]
    [ Halogen.SVG.Elements.svg
        [ Halogen.SVG.Attributes.class_ mdc_checkbox__checkmark
        , Halogen.SVG.Attributes.viewBox "0 0 24 24"
        ]
        [ Halogen.SVG.Elements.path
            [ Halogen.SVG.Attributes.class_ mdc_checkbox__checkmark_path
            , Halogen.SVG.Attributes.fill "none"
            , Halogen.SVG.Attributes.d "M1.73,12.91 8.1,19.28 22.79,4.59"
            ]
            []
        ]
    , HH.div [ HP.class_ mdc_checkbox__mixedmark ] []
    ]
