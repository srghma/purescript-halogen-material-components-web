module HalogenMWC.Slider where

import Protolude
import MaterialIconsFont.Classes
import Web.Event.Event

import Data.Array as Array
import Data.Maybe as Maybe
import Halogen
import Halogen.HTML (IProp)
import Halogen.HTML as HH
import Halogen.HTML.Properties as HP
import Halogen.HTML.Properties.ARIA as Halogen.HTML.Properties.ARIA
import Halogen.SVG.Attributes as Halogen.SVG.Attributes
import Halogen.SVG.Elements as Halogen.SVG.Elements
import Material.Classes.Slider

-- TODO: Prevent FOUC
type Config r i =
  { discrete :: Boolean
    , displayMarkers :: Boolean
    , min :: Maybe Float
    , max :: Maybe Float
    , step :: Maybe Float
    , value :: Maybe Float
    , disabled :: Boolean
    , additionalAttributes :: Array (IProp r i)
    , onInput :: Maybe (Float -> r i)
    }

defaultConfig :: Config r i
defaultConfig =
  { discrete: false
  , displayMarkers: false
  , min: Nothing
  , max: Nothing
  , step: Nothing
  , value: Nothing
  , disabled: false
  , additionalAttributes: []
  , onInput: Nothing
  }

{-| Specify whether a slider is _discrete_

Discrete sliders feature a pin that indicates the current value while
interacting with the slider.

This works best for integer-valued sliders, but this is not a requirement.

-}
{-| Specify whether a slider should display markers

Note that this option is ignored by non-discrete sliders.

-}
slider :: Config r i -> HH.HTML w i
slider (config@{ additionalAttributes }) =
  HH.element (ElemName "mdc-slider")
    ( Array.catMaybes
        [ rootCs
        , displayCss
        , discreteCs config
        , displayMarkersCs config
        , tabIndexProp
        , sliderRoleAttr
        , valueProp config
        , minProp config
        , maxProp config
        , stepProp config
        , disabledProp config
        , ariaValueMinAttr config
        , ariaValueMaxAttr config
        , ariaValuenowAttr config
        , changeHandler config
        ]
        <> additionalAttributes
    )
    [ trackContainerElt
    , thumbContainerElt config
    ]

rootCs :: Maybe (IProp r i)
rootCs = Just (HP.class_ mdc_slider)

displayCss :: Maybe (IProp r i)
displayCss = Just (style "display" "block")

discreteCs :: Config r i -> Maybe (IProp r i)
discreteCs { discrete } =
  if discrete then
    Just (HP.class_ mdc_slider____discrete)
  else
    Nothing

displayMarkersCs :: Config r i -> Maybe (IProp r i)
displayMarkersCs { discrete, displayMarkers } =
  if discrete && displayMarkers then
    Just (HP.class_ mdc_slider____display_markers)
  else
    Nothing

tabIndexProp :: Maybe (IProp r i)
tabIndexProp = Just (HP.tabindex 0)

sliderRoleAttr :: Maybe (IProp r i)
sliderRoleAttr = Just (HP.attr (AttrName "role") "slider")

valueProp :: Config r i -> Maybe (IProp r i)
valueProp { value } = map (HP.prop (PropName "value") <<< Encode.float) value

minProp :: Config r i -> Maybe (IProp r i)
minProp { min } = map (HP.prop (PropName "min") <<< Encode.float) min

maxProp :: Config r i -> Maybe (IProp r i)
maxProp { max } = map (HP.prop (PropName "max") <<< Encode.float) max

stepProp :: Config r i -> Maybe (IProp r i)
stepProp { step } = map (HP.prop (PropName "step") <<< Encode.float) step

disabledProp :: Config r i -> Maybe (IProp r i)
disabledProp { disabled } = Just (HP.prop (PropName "disabled") disabled)

ariaValueMinAttr :: Config r i -> Maybe (IProp r i)
ariaValueMinAttr { min } = map (HP.attr (AttrName "aria-valuemin") <<< String.fromFloat) min

ariaValueMaxAttr :: Config r i -> Maybe (IProp r i)
ariaValueMaxAttr { max } = map (HP.attr (AttrName "aria-valuemax") <<< String.fromFloat) max

ariaValuenowAttr :: Config r i -> Maybe (IProp r i)
ariaValuenowAttr { value } = map (HP.attr (AttrName "aria-valuenow") <<< String.fromFloat) value

changeHandler :: Config r i -> Maybe (IProp r i)
changeHandler { onInput } =
  map
    ( \handler ->
        HE.on "MDCSlider:input"
          (Decode.map handler (Decode.at [ "target", "value" ] Decode.float))
    )
    onInput

trackContainerElt :: HH.HTML w i
trackContainerElt = HH.div [ HP.class_ mdc_slider__track_container ] [ trackElt, trackMarkerContainerElt ]

trackElt :: HH.HTML w i
trackElt = HH.div [ HP.class_ mdc_slider__track ] []

trackMarkerContainerElt :: HH.HTML w i
trackMarkerContainerElt = HH.div [ HP.class_ mdc_slider__track_marker_container ] []

thumbContainerElt :: Config r i -> HH.HTML w i
thumbContainerElt { discrete } =
  HH.div [ HP.class_ mdc_slider__thumb_container ]
    ( if discrete then
        [ pinElt, thumbElt, focusRingElt ]
      else
        [ thumbElt, focusRingElt ]
    )

pinElt :: HH.HTML w i
pinElt = HH.div [ HP.class_ mdc_slider__pin ] [ pinValueMarkerElt ]

pinValueMarkerElt :: HH.HTML w i
pinValueMarkerElt = HH.div [ HP.class_ mdc_slider__pin_value_marker ] []

thumbElt :: HH.HTML w i
thumbElt =
  Halogen.SVG.Elements.svg
    [ Halogen.SVG.Attributes.class_ "mdc-slider__thumb"
    , Halogen.SVG.Attributes.width "21"
    , Halogen.SVG.Attributes.height "21"
    ]
    [ Halogen.SVG.Elements.circle
        [ Halogen.SVG.Attributes.cx "10.5"
        , Halogen.SVG.Attributes.cy "10.5"
        , Halogen.SVG.Attributes.r "7.875"
        ]
        []
    ]

focusRingElt :: HH.HTML w i
focusRingElt = HH.div [ HP.class_ mdc_slider__focus_ring ] []
